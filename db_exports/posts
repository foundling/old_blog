[{"_id":{"$oid":"56391c11848c4d6893f65699"},"author":"alex","content":"If you're familiar with Mr. Show, you may know the technique common to many of their most successful sketches: assiduous repetition of a single idea. It's the key to 'The Story of Everest' and 'The Audition', where the same thing happens again and again, and things gets exponentially funnier.\n\nThe sketch \u003ca href=\"https://www.youtube.com/watch?v=cGuT97v4pv0\"\u003e'Change for a Dollar'\u003c/a\u003e uses this tight repetition to play a good joke on the fate of value in the hands of pure bureaucracy. Oddly, the structure is legimately recursive and I think serves as a good (if not highly alternative) illustration of the winding-and-unwinding process of a recursive program.\n\n![Mr. Show's Bob and David](https://i.vimeocdn.com/video/199532043_640.jpg)\n\nThe gist of the sketch is that a man asks a convenience store clerk to exchange a dollar for four quarters. Instead of just saying yes or no, the clerk, after some delay, has to ask his boss for permission, and it turns out his boss must also, after some delay, ask *his* boss for permission. This continues until the original request reaches an employee with the credentials to say yes or no. At that point, the answer propagates back through each boss to the requesting underling. When that underling is the store clerk, he can tell the customer the answer.\n \nIn terms related to recursion, each scene is the execution context of a new function placed on top of the call stack that stores the state of this `change_for_a_dollar` program. If the arguments to the function are `employee` and `boss`, then at the end of the function call, we call the function again with `employee.boss` and  In each scene, the employee seeks authorization from his boss to make change for a dollar. If the employee's boss isn't able to authorize, he has to call *his* boss.\n\nBelow, I've created a basic model to represent the chain of command in this haplessly bureaucratic corporation (notice that employee5 is the only one who has the `authorize` method, meaning only he can sign off on the 'change for a dollar' request): \n\n\u003cpre\u003e\n\u003ccode class='language-javascript'\u003e\nvar employee5 = {\n  name: 'President of the United States',\n  boss: null,\n  authorize: function() {\n    return 'no';\n  }\n};\nvar employee4 = {\n  name: 'Corporate Executive',\n  boss: employee5,\n};\nvar employee3 = {\n  name:'Regional Manager',\n  boss: employee4,\n};\nvar employee2 = {\n  name:'Store Manager',\n  boss: employee3,\n};\nvar employee1 = {\n  name:'Store Clerk',\n  boss: employee2,\n};\n\u003c/code\u003e\n\u003c/pre\u003e\n\nThe five employee objects make up a singly-linked-list where each employee save the last has a reference to his boss, who has a reference to his boss, etc. We can use this structure to recurse through the list until an employee with an `authorize` method is found.\n\n\u003cpre\u003e\n\u003ccode class='language-javascript'\u003e\nvar customer = {\n  name: 'customer',\n  say: function(phrase) { console.log(phrase)},\n  getChangeForADollar: function(employee) {\n    if (employee.authorize) {\n      var answer = employee.authorize();\n      return 'the answer is ' + answer +'.'; \n    }\n    else {\n      return this.getChangeForADollar(employee.boss);\n    }\n  }\n};\n\u003c/code\u003e\n\u003c/pre\u003e\n\nWhen the `authorize` method is found on an employee, the results of that method call are returned. This is our base case, and causes each function on the call stack to resolve its return value until the original caller is reached. \n\n\u003cpre\u003e\n\u003ccode class='language-javascript'\u003e\ncustomer.say('Can I get change for a dollar?');\nconsole.log(customer.getChangeForADollar(employee1));\n\u003c/code\u003e\n\u003c/pre\u003e\n\nWhy is this not iterative?\n\nJust in case you were wondering why I'm making a big deal about this being a good example of recursion instead of iteration using a while loop, there are two reasons:\n\n  1. The context for each authorization check is a totally new location relative to the specific employee and boss involved. If the sketch demonstrated iteration (like 'Story of Everest' and 'The Audition' mentioned above), the context of the employee traversal process would be the `customer.getChangeForADollar` method throughout, aka, the whole sketch would have to take place in the convenience store. \n  2. The sketch demonstrates an explicit 'unwinding' phase where the ultimate answer is relayed from the top of the command-chain, through each boss and underling, to the caller and in exactly the reverse order of the recursive calls. I'd go so far as to say that this unwinding phase contains the punchline of the joke.  \n\nAll of this is just to demonstrate that while a *good* joke may use repetition, it is the rare comedic gem that implements it recursively! In any case, I'm sure that my analysis eventually breaks down, so if *you* are interested in telling me exactly where it does, I would be flattered. You can call me on my twitterphone, the number is \u003ca href=\"https://twitter.com/drlolzrofl\"\u003e@drlolzrofl\u003c/a\u003e. \n\n[note: there are almost exclusively gendered pronouns in this post and the reason is simply that the relevant roles in the sketch are played by David Cross and Bob Odenkirk, who in fact play all of the employees and bosses.]\n\n","date":{"$date":"2015-11-03T12:41:53.881Z"},"permalink":"good-joke-vs-great-joke","post_id":1,"short_text":"If you're familiar with Mr. Show, you may know the technique common to many of their most successful sketches: assiduous repetition of a single idea. It's the key to 'The Story of Everest' and 'The Audition', where the same thing happens again and again, and things gets exponentially funnier.","tags":["jokes","recursion","mr. show","javascript"],"title":"Good Joke, Great Joke"},{"_id":{"$oid":"563a806a848c4d745df67ba8"},"author":"alex","content":"In this tutorial, I’m going to show you how to install and configure a Raspberry Pi model B running the Raspbian Linux distribution. The goal is to get your pi ready for an as-of-yet undetermined but fun purpose. By the end of this you should have an SSH-accessible system configured with a static IP for your home LAN network.  \n\nIn follow-up posts, I’ll demonstrate a few practical uses I’ve found for it, such as a samba share, a web server, a webcam, a server for a python network game, and I'll share some system administration tips as well.\n\nI'll show GUI options when appropriate but the command-line is going to be the main focus here.  \n\n## What You Need\n\n+ A raspberry Pi model with a 5V microUSB power supply \u003ca href=\"#raspi_b\"\u003e\u003ci class=\"fa fa-camera-retro\"\u003e\u003c/i\u003e\u003c/a\u003e\n\n+ An extra Ethernet cable \u003ci class=\"fa fa-camera-retro\"\u003e\u003c/i\u003e\n\n+ A Wifi Router and Internet Access \u003ci class=\"fa fa-camera-retro\"\u003e\u003c/i\u003e\n\n+ An SD card or a microSD card and a microUSB adapter that is 4GB or larger in size.  If you are going to purchase one, do some research on quality, not all SD cards yield good results. \u003ci class=\"fa fa-camera-retro\"\u003e\u003c/i\u003e\n\n+ An SD card reader (if you have a MacBook, iMac or Mac Mini, it may be built into your computer) \u003ci class=\"fa fa-camera-retro\"\u003e\u003c/i\u003e\n\n+ A Mac on which you have administrative privileges, preferably one with data that other people don't depend on or hold dear \u003ci class=\"fa fa-camera-retro\"\u003e\u003c/i\u003e\n\n## Formatting the SD Card\n\nBefore you insert the SD card, open the Terminal (tip: Cmd spacebar type ‘Termi…’ hit Enter)\n\nType `diskutil list` and note the device output. If no other disks are attached at this time, you will likely see just the `/dev/disk0` device and its partitions, `/dev/disk0s1`, `/dev/disk0s2`, etc.  These are the BSD device labels.\n\nAfter we insert the SD card, `diskutil list` should reveal an additional mounted device, most likely at `/dev/disk1`. You want to make sure you reformat this disk, which is why we taking a safer route and comparing the output list before and after we insert the card. If you reverse the source and destination of the copy utility we will use, you will erase the data on your hard drive.\n\nInsert the SD card into a card reader or into your Mac.\n\nType `diskutil list` again.\n\nNote the newly added disk’s device name.  For me, it was `/dev/disk1`.\n\nUnderstand the difference between `/dev/disk1` and `/dev/disk1s0` or `/dev/disk1s1`, etc.  The first describes the physical device, the latter examples refer to the logical partitions on that device. We will be writing a group of filesystems that comprise the Raspbian OS to the new `/dev/disk1` device.\n\nOpen Disk Utility.\n\nYou should see your disk in the left pane. Mine says 7.86GB Apple SDXC Reader.\n\nFind the erase Tab and change the format to MS-DOS(FAT).\n\nName your disk, e.g. RASPI.\n\nHit Erase.\n\nUnmount the disk but don’t eject it.  You can do this with the terminal command \n\n\u0009sudo diskutil unmount /dev/disk1\n\n## Getting and Preparing the Raspberry Pi Operating System Image\n\nDownload the latest Raspbian image from the Raspberry Pi website in either \n\u003ca class=\"article-link\" href=\"http://downloads.raspberrypi.org/raspbian_latest\"\u003eZIP format\u003c/a\u003e or as\n\u003ca class=\"article-link\" href=\"http://downloads.raspberrypi.org/raspbian_latest.torrent\"\u003ea torrent\u003c/a\u003e.\n\nIf you downloaded a ZIP file, unzip it. If you torrented it, you most likely got an IMG file.\n\nI’m assuming the unzipped Raspbian .img file is located in your `~/Downloads` folder, aka `/Users/\u003cUSERNAME\u003e/Downloads`, but if it is in a different location, adjust the upcoming `dd` commands to reflect that.\n\nRecall the device name of the SD card that you recently reformatted. In my case, it is `/dev/disk1`.  You will write the Raspbian image to this device with the BSD utility, `dd`. `dd` is a low-level block copying utility that comes in extremely handy in Unix/BSD-related tasks, but it is nick-named ‘disk destroyer’ for a reason.  Be careful to get the source (designated by `if`, the input file) and destination (designated by `of`, the output file) file paths correct.\n\nWe want to use dd in this way:\n\n\u0009dd  if=\u003cRPI IMAGE FILE\u003e of=\u003cDESTINATION DEVICE\u003e bs=\u003cblock size\u003e\n\nThis command copied the raspbian image to the FAT32-formatted SD device named ‘RASPI’ on my Mac.  It took me just under 35 minutes for the image writing process to complete.\n\n\u0009sudo dd if=~/Downloads/2014-09-09-wheezy-raspbian.img of=/dev/disk1 bs=1m\n\n\n## Getting a Read on the Progress of `dd`\n\n`dd` doesn’t give you any visible indication of its progress, but you can figure this out yourself by pressing `CTRL T` in the terminal where the dd copy is presently working.  `CTRL T` sends the `dd` process a `SIGINFO` signal that will return cpu load information to the console, as well as a read on how many bytes have been transferred by `dd` and the duration in seconds of the copy thus far.\n\nThe output is something like this:\n\n\u0009309329920 bytes transferred in 195.748521 secs ( 1580241 bytes/sec)\n\nWith a little math, we can get the progress so far: \n\nbytes copied / disk image size = % done\n\n309,329,920 / 3,100,000,000 or roughly 1 % done.\n\n\u0009user@host:~ $ du -sh ~/Downloads/2014-09-09-wheezy-raspbian.img\n\u00093.1G\u0009/data/ISO/2014-09-09-wheezy-raspbian.img\n\ndisk image size = 3.1 GB\n\nprogress = .31GB/3.1GB = .1 = 10% done\n\n## Network Setup\n\nNow that your raspberry pi is properly imaged, connect it to an ethernet port on your wifi router.\n\nConnect the micro-usb power source and plug it in. You should see a red light that indicates power.  Soon after you should see a few other lights (yellow and green), that indicate that the system is booting and that the network connection is active.\n\nIf this doesn’t happen for you, you can look at the light labels on the board and troubleshoot accordingly.  They are as follows:\n\n**ACT** — SD Card Access\n\n**PWR(RED)** - The device is powered\n\n**FDX** - Full Duplex mode is enabled\n\n**LNK** -  The Ethernet LINK is present\n\n**100** - a 100MBit connection is active \n\n\nIf all has gone well, the raspberry pi should have booted up and received an ip address from your wifi router.\nYou can find the raspberry pi with the Terminal application in a few ways:\n\n### Method 1: Find it through your Wi-Fi Router\n\nLog into the admin panel of your wifi router and look for connected devices.  It may reveal the hostname and IP address of the pi.  It showed mine as hostname raspberrypi with the IP address 192.168.1.10.  However, if your wireless router's firmware is old, it software may not show you this information.  \n\n### Method 2: Use nmap for MAC/BSD\n\nDownload and install nmap for mac, run `sudo nmap -sP 192.168.0.0/24` from your Mac Terminal.\n\n\n### Method 3: Brute Force\n\nIf you can’t or don’t want to download any extra tools and you’re on your own network, you can try a brute-force approach by pinging all of the possible IP addresses on your network once, and with a brief timeout setting. This is how you’d do it in bash:\n\n\u0009for i in {1..254}; do ping -c1 -t1 192.168.1.$i; done | grep -B 1 \" 0.0% packet loss\"\n\nThis will ping every ip address on your network once and wait a second before moving on, regardless of the result.  We are looking for a ping that results in %0.0 packet loss, and getting that line of text plus the previous line, where I know the IP address is usually output.\n\nIt should reveal the IP address of any system that respond to ping, but not the hostname.  But if you have only a handful of devices connected to your router, then the process of elimination shouldn't be too hard.\n\nIf you think you've found the pi's address, you can cancel the for loop by typing CTRL \\ into the terminal.  This sends a SIGQUIT signal to the bash process running the loop.\n\nNote: this method is permissable on your private network, but I don’t recommend doing it on a monitored network where such activity might be flagged as suspicious.\n \nIf you’ve found the IP address of the pi, then type `ssh pi@raspberrypi`. You will likely see a message that says:\n\n    - `‘The authenticity of the host ‘xxx.xxx.xxx.xxx’ can’t be established. Are you sure you want to continue connecting (yes/no)?’.`\n\n\nType ‘yes’ and enter ‘raspberry’ as the password.\n\nIf you end up at a command prompt that says ‘pi@raspberrypi’, then congratulations! You got your pi online! \n\n… but we have more to do. :]\n\n\n## Resetting the Password\n\nType `sudo raspi-config` and select item #2, \"Change User Password\"\n\nEnter your new password twice.\n\nTry logging out and then back in.  Your new password should work with the user `pi`, and you shouldn’t see the previous message regarding the questionable authenticity of this system's RSA key.\n\n## Updating Current Packages\n\nRun `sudo apt-get update` and wait a bit\n\n## Leaving the Pi on DHCP (the default)\n\nSetting a static IP allows you to know the address of the PI at boot time, but it requires a little work.  If you don't want to set up a static IP on your WIFI network, you can avoid the tedious process of looking for the pi each time by creating a boot script that pings your router when the PI starts up.  What this does is tell the router about its IP address, which gets passed to you when you run `arp -a ` on Linux/BSD/MAC system that is connected the router.  From there, you can deduce the proper IP.  For obvious reasons, a static IP is probably a better route, as your WIFI router's lease may expire and the IP may change.\n\nYou can create a boot script called `pingrouter` on the Pi by creating a file called `/etc/init.d/pingrouter` with the following lines:\n\n\u0009#!/bin/bash\n\u0009# This command will unconditionally run at boot\n\u0009ping -c1 192.168.1.1\n\nThen run these commands:\n\n\u0009user@host:~ $ sudo chmod 755 /etc/init.d/pingrouter \n\u0009user@host:~ $ sudo update-rc.d pingrouter defaults\n\n## Assigning the System a Static IP\n\nIt is better to understand the IP address `192.168.1.10` as consisting of two addresses, a network address and a host address.  The network address identifies the internet that the host is on, e.g.,  `192.168.1`.  The host address indicates *which* host on that network, e.g.  `10`.\n\nTo assign the pi a static IP so that it boots with the same IP address each time, we need to figure out 5 things:\n\n  - The DHCP range of the WIFI router\n\n  - The Netmask\n\n  - The Network Address\n\n  - The Broadcast Address\n\n  - The Gateway Address\n\nIn a terminal, run `ifconfig`.  This lists your network devices and the IP address information obtained by them.  Not all will have an IP address, so we need to look for an `inet` entry.  \n\nThis is the output of `ifconfig` on my system from my private LAN:\n\n\u0009en0: flags=8863\u003cUP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST\u003e mtu 1500\n\u0009\u0009options=27\u003cRXCSUM,TXCSUM,VLAN_MTU,TSO4\u003e\n\u0009\u0009ether 34:15:9e:13:0c:4e \n\u0009\u0009nd6 options=1\u003cPERFORMNUD\u003e\n\u0009\u0009media: autoselect\n\u0009\u0009status: inactive\n\u0009en1: flags=8863\u003cUP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST\u003e mtu 1500\n\u0009\u0009ether f8:1e:df:e4:e3:3e \n\u0009\u0009inet6 fe80::fa1e:dfff:fee4:e33e%en1 prefixlen 64 scopeid 0x5 \n\u0009\u0009inet 192.168.1.6 netmask 0xffffff00 broadcast 192.168.1.255\n\u0009\u0009nd6 options=1\u003cPERFORMNUD\u003e\n\u0009\u0009media: autoselect\n\u0009\u0009status: active\n\u0009fw0: flags=8863\u003cUP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST\u003e mtu 4078\n\u0009\u0009lladdr 34:15:9e:ff:fe:13:0c:4e \n\u0009\u0009nd6 options=1\u003cPERFORMNUD\u003e\n\u0009\u0009media: autoselect \u003cfull-duplex\u003e\n\u0009\u0009status: inactive\n\u0009p2p0: flags=8843\u003cUP,BROADCAST,RUNNING,SIMPLEX,MULTICAST\u003e mtu 2304\n\u0009\u0009ether 0a:1e:df:e4:e3:3e \n\u0009\u0009media: autoselect\n\u0009\u0009status: inactive\n\nNotice that the `en1` device has an `inet` address.  We'll use this section to determine the necessary addresses for the pi's static IP.\n\n### Netmask\n\nThe output for `en1` indicates (in hexidecimal) that the Netmask is `0xffffff00`, which is `255.255.255.0` in dotted decimal, the IP address notation you are probably most familiar with. The Netmask tells you where in the ip address the network address ends and the IP address space begins. A network with the netmask `255.255.255.0` reserves the first 3 dot-separated numbers for representation of the network. The last number, excluding 3 special addresses, indicates the total possible host addresses on that network, so 256-3, or 253.\n\nWhat We Have So Far (**Netmask**)\n\n\u0009DHCP RANGE:  \n\u0009The Network Address: \n\u0009The Gateway Address: \n\u0009The Netmask: 255.255.255.0\n\n\nNetwork Address: the netmask `255.255.255.0` indicates a network address of 3 'octets' in length. The Network address is simply the first 3 octets of the inet address you found in the `ifconfig` output, with a 0 as the last octet.\n\n\nWhat We Have So Far (**Netmask** and **Network Address**)\n\n\u0009DHCP RANGE:\n\u0009The Network Address: 192.168.1.0\n\u0009The Gateway Address:\n\u0009The Netmask: 255.255.255.0\n \n\nGateway: since we know the Network Address now, the gateway is simply the second possible address in ascending order, so `192.168.1.1`.  This Gateway is also your WIFI router's address.\n\nWhat We Have So Far (**Network Address**, **Gateway Address** and **Netmask**)\n\n\u0009DHCP RANGE:\n\u0009The Network Address: 192.168.1.0\n\u0009The Gateway Address: 192.168.1.0\n\u0009The Netmask: 255.255.255.0\n\n## Your Router's DHCP range\n\nWhen we set a static IP, we don't want it to conflict with an address reserved for automatic/dynamic assignment, which the WIFI router takes care of.  We need to log into our WIFI router's administration panel and find the DHCP range.  Since I have no idea what your WIFI router model is, I can only advise that you look for the DHCP range settings in the LAN Administration in your WIFI Admin panel, or look that information up in the manual for your router (can probably be found online if it's at least somewhat recent).  My WIFI router reserves addressess `192.168.1.2` through `192.168.1.100` for DHCP addresses.  This means that anything from `192.168.1.101` through `192.168.1.254` is technicially available, assuming I configured any other static IP devices on this network.\n\n\nWhat We Have So Far (**Network Address**, **Gateway Address** and **Netmask**, **Broadcast Address** and **DHCP range**)\n\n\u0009DHCP RANGE: 192.168.1.2 thru 192.168.1.100\n\u0009The Network Address: 192.168.1.0\n\u0009The Gateway Address: 192.168.1.1\n\u0009Broadcast Address 192.168.1.255\n\u0009The Netmask: 255.255.255.0\n\nWe have all of the relevant information to configure a static IP. Let's edit our network settings file,  `/etc/network/interfaces` to give the pi a fixed IP address . \n\nBut first, let’s back that up that so  we can modify it while keeping the original in tact. In a Terminal window, run \n\u0009\n\u0009sudo cp /etc/network/interfaces /etc/network/interfaces.orig\n\nNow lets modify the contents of `/etc/network/interfaces`. The default file looks like this:\n\n\u0009auto lo\n\n\u0009iface lo inet loopback\n\u0009iface eth0 inet dhcp\n\n\u0009allow-hotplug wlan0\n\u0009iface wlan0 inet manual\n\u0009wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf\n\u0009iface default inet dhcp\n\nWe need to change it to this (note the arrows, which do not actually go in the file)\n\n\u0009bash\n\u0009allow-hotplug wlan0\n\u0009iface wlan0 inet manual\n\u0009wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf\n\u0009iface default inet static \u003c--\n\n\u0009address 192.168.1.10\n\u0009--\u003e gateway 192.168.1.1\n\u0009--\u003e netmask 255.255.255.0\n\u0009--\u003e network 192.168.1.0\n\u0009--\u003e broadcast 192.168.1.255\n\n\u0009allow-hotplug wlan0\n\u0009iface wlan0 inet manual\n\u0009wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf\n\u0009iface default inet dhcp\n\n## Starting and restarting network services\n\nThis part should be completed soon.\n\n## Expanding the root partition\n\nWe wrote a 2.9GB root filesystem to the SD card, but that means whatever space is left on the card isn’t presently usable. For me, that’s about 5GB of space.  Fortunately, the Raspbian Image developers have provided us with a convenient ‘Expand Filesystem’ option in the same `raspi-config` panel we just used to set our password.\n\n\nType `sudo raspi-config` again\n\nchoose option #1\n\nIt should say, “Root partition has been resized … ”. Hit OK, choose Finish at the bottom, and say yes to the reboot option.  Since we’ve already set a static ip for the pi, rebooting won’t mean we have to go looking for the ip again.\n","date":{"$date":"2015-11-04T14:02:18.714Z"},"permalink":"getting-started-with-the-raspberry-pi","post_id":2,"short_text":"In this tutorial, I’m going to show you how to install and configure a Raspberry Pi model B running the Raspbian Linux distribution. The goal is to get your pi ready for an as of yet undetermined but fun purpose. By the end of this you should have an SSH-accessible system configured with a static IP for your home LAN network.  ","tags":["raspberry pi","linux"],"title":"Getting Started with the Raspberry Pi"},{"_id":{"$oid":"5643a178848c4def3cbd3662"},"author":"alex","content":"This thing has been in the works and has undergone design revisions for way too long, but I finally worked out a process that made sense, and here it is!\n\n","date":{"$date":"2015-11-11T12:13:44.227Z"},"permalink":"website-launch","post_id":3,"short_text":"This thing has been in the works and has undergone design revisions for way too long, but I finally worked out a process that made sense, and here it is!","tags":["news"],"title":"Website Launch"}]
