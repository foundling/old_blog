#!/usr/bin/env python
''' 
    This script takes a file path as an argument and does the following:
        - creates a post object
        - takes user input regarding the post name, author and keywords
        - adds these to the object
        - reads the file content and calculates an excerpt
        - adds these to the object
        - connects to a mongodb 'blog' database 'post' collection
        - inserts the post object into the post collection
        - asserts that the same thing that was inserted is retrievable

        TODO: add type: field, aka, blogpost, staticpost
'''

from config import config
from lib import utils

def get_short_text(file_content):
    return file_content.split('\n')[0] 

def append_user_values(post):
    prompt_questions = {
                            'title':'Title:',
                            'author':'Author:',
                            'keywords':'Keywords:',
                            'type:':'Type',
                            'published':'Publish? (y/Y) [default: no/draft]:',
                       }

    for category in prompt_questions:

        raw_string = raw_input(prompt_questions[category])

        if category == 'keywords':
            ''' process keywords by splitting string, stripping, lowercasing words'''
            post[category] = [ kw.strip().lower() for kw in raw_string.split(',') ] 

        elif category == 'published':
            ''' map text to boolean values '''
            post[category] = True if raw_string.strip() in ('y','Y') else False

        else:
            post[category] = raw_string.strip()

    return post

def append_automatic_values(client, post):

    post['date_published'] = datetime.datetime.now() 
    post['content'] = open(sys.argv[1]).read().decode('utf-8')
    post['short_text'] = get_short_text(post['content'])
    post['post_id'] = client.blog.posts.find().count() + 1

    return post

def save_version(post):
  ''' 
    take current title entered to update
    find version titles of which the name is a subset
    get the largest version number
    increment it and save a new file with the current name and the incremented version
  '''

  new_filename = post['title']
  content = post['content']
  current_date = datetime.datetime.isoformat(datetime.datetime.now())
  f = open(config['versions_dir'] + '/' + new_filename + '_' + current_date, 'w')
  f.write(content)
  f.close()
  # new filename should be a subset of versioned filenames with one or more digits at the end, or its not a match


def connect(host='localhost',port='27017'):

    serverIsRunning = os.system('pgrep -q mongod') == 0

    if not serverIsRunning:
        print 'mongod server is not running. start it and run the script again'
        sys.exit(1)

    try:
        client = pymongo.MongoClient(''.join([
                                        'mongodb://',
                                        host,
                                        ':',
                                        port,
                                        '/',
                                        ]),
                                        connectTimeoutMS=1000
                                     )
    except pymongo.errors.ConnectionFailure:
        return False

    return client


def main():

    client = connect()
    post = {}
    post = append_user_values(post)
    post = append_automatic_values(client, post)
    save_version(post)
    client.blog.posts.insert_one(post)
    client.close()

if __name__ == '__main__':

    try:
        import arrow
        import datetime
        import json
        import os 
        import pprint
        import re
        import sys
        import pymongo

    except ImportError as err:
        utils.usage("You Probably didn't source your virtual environment. Do that and try\
               again!", err) 
        sys.exit(1)


    if len(sys.argv) < 2:
        utils.usage()
        sys.exit(1)

    else:
        main()
